{"./":{"url":"./","title":"Code an OS Project","keywords":"","body":"Code an OS Project 这个文档记录了这个实验与教学性质的操作系统的开发完善过程（当然不包含一些曾经使用过但后来弃用的一些内容）。我们希望这个文档足够详细，让有兴趣的同学可以参照这个文档一步一步完整地实现一个一样的操作系统，甚至在此基础上有所改进。 这份文档所对应的代码都可以在 LZU-OSLab/lzu_oslab: A simple OS running on RISC-V for education 中找到。 小知识有时候文档里会出现此类带有小知识标题的引用块，只是做一些相关的介绍，感兴趣的同学可以看一看作为补充知识，不了解也不影响相关任务。 本网站使用 Gitbook 创建，开源在 Github 上，使用 Travis CI 自动构建，在线阅读链接：https://lzu-oslab.github.io/step_by_step_doc/ By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2021-01-22 03:00:21 "},"ready/":{"url":"ready/","title":"准备","keywords":"","body":"准备 工欲善其事，必先利其器。在这一章我们会准备好敲代码、测试和调试的整个环境。 敲代码的工具自然是可以自由选择，作为这个文档的编写者我推荐使用 Visual Studio Code ，微软开发的跨平台编辑器，装上几个插件可以说是非常好用了，这个系统的另几位编写者则有其他的编辑器使用，比如 Kong Jun 大佬就使用了他最趁手的 Neovim 代码编辑器。 小知识：vi 编辑器家族 vi是一种计算机文本编辑器，由美国计算机科学家比尔·乔伊（Bill Joy）完成编写，并于1976年以BSD协议授权发布。—— vi - 维基百科，自由的百科全书 Vim是从vi发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和Emacs并列成为类Unix系统用户最喜欢的编辑器。Vim的第一个版本由布莱姆·米勒在1991年发布。对于大多数用户来说，Vim有着一个比较陡峭的学习曲线。这意味着开始学习的时候可能会进展缓慢，但是一旦掌握一些基本操作之后，能大幅度提高编辑效率。 Neovim是Vim的一个重构版本，致力于成为Vim的超集（superset）。Neovim和Vim配置文件采用相同的语法，所以Vim的配置文件也可以用于Neovim。Neovim的第一个版本在2015年12月发行，并且能够完全兼容Vim的特性。Neovim项目从2014年发起，有许多来自Vim社区的开源开发者为其提供早期支持，包括更好的脚本支持、插件以及和更好地融合图形界面等。相比于Vim，Neovim的主要改进在于其支持异步加载插件。此外，Neovim的插件可以用任意语言编写，而Vim的插件仅能使用Vimscript进行编写。—— Vim - 维基百科，自由的百科全书 更多资料：Vim 和 Neovim 的前世今生 - jdhao's blog 运行的环境自然也是可以选择自己喜欢的环境，我比较喜欢 Ubuntu 系的发行版，因此环境配置说明我就选择了基于 Ubuntu 平台的配置方法，其他的 Linux 发行版也可以自由选择，不要太古老就好，比如 Kong Jun 大佬喜欢使用他的 Fedora) 系统。另外喜欢使用 Windows 的同学也可以尝试使用 WSL。 小知识：适用于 Linux 的 Windows 子系统（Windows Subsystem for Linux，WSL） 适用于 Linux 的 Windows 子系统（即 WSL）可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销。WSL 2 是适用于 Linux 的 Windows 子系统体系结构的一个新版本，它支持适用于 Linux 的 Windows 子系统在 Windows 上运行 ELF64 Linux 二进制文件。 它的主要目标是提高文件系统性能，以及添加完全的系统调用兼容性。—— 关于适用于 Linux 的 Windows 子系统 | Microsoft Docs注：上文中提到的 GNU/Linux 就是 Linux 简单来说，Windows 和 Linux 的运行环境、系统调用、可执行文件的格式等都是不同的，对于习惯于 Windows 系统使用的我们来说，偶尔要使用一次 Linux，装一个 Linux 系统或者建一个 Linux 虚拟机似乎没有很大的必要，就可以使用 WSL 在 Windows 下运行 Linux 的程序——没错，我们的项目所用到的都是 Linux 下的程序。 那么，下面就让我们开始吧。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2021-01-22 03:00:21 "},"ready/intro.html":{"url":"ready/intro.html","title":"总体介绍","keywords":"","body":"总体介绍 RISC-V 硬件指令集架构千千万，我们选择64位 RISC-V，无他，只是因为这个项目开始时老师推荐使用罢了（笑 先来简单介绍一下 RISC-V，这是一个与 x86 有相当大的区别的开源 RISC 指令集，由加州伯克利和校外的几位大佬共同开发，项目始于2010年，因此是个非常年轻的指令集架构，没有很多的历史包袱，一切从简，并且根据已有的指令集架构的优点和不足做了很多的改进，因此是一个非常“摩登”的指令集架构。它采用模块化设计，64位的 RISC-V 基本指令集称为 RV64I（这里的 I 代表整数的意思，即这是一个64位的基本整数指令集），在此基础上可以扩展不同的指令集（如乘法、单双精度浮点的支持等），详细可见 RISC-V 维基百科。 RISC-V 作为精简指令集 (reduced instruction set computer，RISC)，有大多数精简指令集架构都有的一大特性：通用寄存器（没有特殊用途可被任意使用的寄存器）非常多。在汇编代码层面与传统 x86 这类复杂指令集 (Complex Instruction Set Computer，CISC) 的汇编语言也有很大的不同，比如没有入栈出栈的汇编语句，当然入栈和出栈的操作还是有的，但这就需要我们使用访存指令和栈指针的寄存器的加减来实现此类操作。具体指令当我们需要用到时会再介绍。 小知识：精简指令集计算机 (reduced instruction set computer，RISC) 精简指令集计算机（英语：reduced instruction set computer，缩写：RISC）或简译为精简指令集，是计算机中央处理器的一种设计模式。这种设计思路可以想像成是一家模块化的组装工厂，对指令数目和寻址方式都做了精简，使其实现更容易，指令并行执行程度更好，编译器的效率更高。目前常见的精简指令集微处理器包括DEC Alpha、ARC、ARM、AVR、MIPS、PA-RISC、Power ISA（包括PowerPC、PowerXCell）、RISC-V和SPARC等。—— 精简指令集计算机 - 维基百科，自由的百科全书 指令集的每一条指令的实现都需要花费芯片的一部分面积，精简指令集的一大思想就是只保留最常用的和不可缺少的指令，其余功能通过指令组合来实现，这样指令的译码、执行等所占用的芯片面积较少，在同样的面积下可以比复杂指令集放下更多的通用寄存器（如 RISC-V 有32个通用寄存器）以减少内存访问，加快速度（访问速度：寄存器 > Cache >> 内存）。   存储器层次结构 存储器从上到下速度降低，价格降低，容量提升。寄存器是封装在 CPU 核心内部的临时存储器，与 CPU 距离最近，速度最快，容量最小，价格最贵。 RISC-V 处理器通常有 3 个特权级，由高到底分别为 M 模式（machine mode）、S 模式（supervisor mode）和 U 模式（user mode）。M 模式下运行最受信任的代码，S 模式下运行操作系统，U 模式下运行用户程序。M 模式下的代码对整个系统拥有绝对控制权，可以控制一切硬件资源。 Supervisor 二进制接口（SBI） RISC-V 标准还规定了一套 Supervisor 二进制接口（SBI），它运行于 M 模式，掌控着整台计算机，你可以认为它是 RISC-V 上的 BIOS（BIOS又可以看作是最底层的直接接触硬件的一个基本操作系统），它提供了一些环境调用的支持，对更底层的硬件做了一部分的抽象和封装。一般来说，操作系统都不会直接管理硬件资源，而是会通过环境调用来让 SBI 协助管理。 SBI，或者Supervisor Binary Interface，是操作系统向底层（虚拟层、中间件、固件等等）提出服务请求的接口。 从优先级来说，也就是S模式下的程序向M(H)模式的服务程序提出请求的API接口。从软件体系来说，操作系统通过SBI向底层硬件提出服务请求，某种程度上SBI为操作系统提供了针对底层硬件的隔离。 —— CNRV双周简报（2018-12-11）- 技术讨论 - 让我们重新思考SBI的定义 ( archive.is互联网存档 )（写的不错，建议阅读，了解一下当初讨论的几种思想） SBI 只是一个规范，根据这个规范，不同的厂家（或程序员）可以编写不同的 SBI 程序，一个完整的符合 SBI 规范的程序称为 SBI 实现（下面简称 SBI ），RISC-V 官方做了一个 SBI 实现，叫 OpenSBI，此外还有其他的 SBI 实现，如 BBL、RustSBI 等。SBI 是一个刷写在主板上的程序。 操作系统作为一个程序，必须加载到内存里才能执行。而“把操作系统加载到内存里”这件事情，不是操作系统自己能做到的，就好像你不能拽着头发把自己拽离地面。 因此我们可以想象，在操作系统执行之前，必然有一个其他程序执行，他作为“先锋队”，完成“把操作系统加载到内存“这个工作，然后他功成身退，把CPU的控制权交给操作系统。 这个“其他程序”，我们一般称之为 bootloader。很好理解：他负责boot(开机)，还负责load(加载OS到内存里)，所以叫bootloader。 —— 内存布局，OpenSBI，elf和bin - ucore step by step 在 RISC-V 中，这个 bootloader 就是 SBI，或者更确切地说，充当 bootloader 就是 SBI 的一部分功能。 计算机的启动顺序：上电 -> 运行 SBI -> SBI 加载运行操作系统 -> 操作系统加载普通用户程序 如果还是不明白 SBI 是什么，没有关系，具体是什么可能不重要，它能干什么后面也会讲到，不用担心，这并不影响后续的学习。 GCC 没错，我们使用 GCC，我们使用 C 语言（虽然GCC已经能编译很多其他语言了），因为大学期间我们学得最早也用得比较熟练的操作系统编程语言就是 C 语言了，其余的底层（可直接控制内存）编程语言如 Rust 语言在大学课程里出现比较罕见，自学的学习曲线也比较陡峭（就是说很难入门），因此我们还是选择比较传统且“落后”的 C 语言。 这里我们使用的 GCC 不是一般的 GCC，而是可以在 x86 架构下编译出 RISC-V 代码的交叉编译器。 交叉编译 在解释什么是交叉编译之前，先要明白什么是本地编译。 本地编译可以理解为，在当前编译平台下，编译出来的程序只能放到当前平台下运行。平时我们常见的软件开发，都是属于本地编译：比如，我们在 x86 平台上，编写程序并编译成可执行程序。这种方式下，我们使用 x86 平台上的工具，开发针对 x86 平台本身的可执行程序，这个编译过程称为本地编译。 交叉编译可以理解为，在当前编译平台下，编译出来的程序能运行在体系结构不同的另一种目标平台上，但是编译平台本身却不能运行该程序：比如，我们在 x86 平台上，编写程序并编译成能运行在 ARM 平台的程序，编译得到的程序在 x86 平台上是不能运行的，必须放到 ARM 平台上才能运行。 之所以要有交叉编译，主要原因是： Speed： 目标平台的运行速度往往比主机慢得多，许多专用的嵌入式硬件被设计为低成本和低功耗，没有太高的性能Capability： 整个编译过程是非常消耗资源的，嵌入式系统往往没有足够的内存或磁盘空间Availability： 即使目标平台资源很充足，可以本地编译，但是第一个在目标平台上运行的本地编译器总需要通过交叉编译获得Flexibility： 一个完整的Linux编译环境需要很多支持包，交叉编译使我们不需要花时间将各种支持包移植到目标板上—— 什么是交叉编译_whatday的专栏   小知识：GCC GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。 原名为GNU C语言编译器（GNU C Compiler），因为它原本只能处理C语言。GCC在发布后很快地得到扩展，变得可处理C++。之后也变得可处理Fortran、Pascal、Objective-C、Java、Ada，Go与其他语言。 许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。 —— GCC - 维基百科，自由的百科全书 GDB 既然用了 GCC，那就用配套的调试平台 GDB 吧，没有什么其他的原因。 小知识：GDB GNU调试器（英语：GNU Debugger，缩写：GDB），是GNU软件系统中的标准调试器，此外GDB也是个具有移携性的调试器，经过移携需求的调修与重新编译，如今许多的类UNIX操作系统上都可以使用GDB，而现有GDB所能支持调试的编程语言有C、C++、Pascal以及FORTRAN。 —— GNU调试器 - 维基百科，自由的百科全书   小知识：GNU工具链 GNU工具链（英语：GNU toolchain）是一个包含了由GNU计划所产生的各种编程工具的集合，由自由软件基金会负责维护工作。这些工具形成了一条工具链，用于开发应用程序和操作系统。 组成（加粗部分是我们会使用到的）：GNU make：用于编译和构建的自动工具GNU编译器集合（GCC）：一组多种编程语言的编译器GNU Binutils：包含链接器、汇编器和其它工具的工具集GNU Bison: 编译器编译程序，经常和 Flex词法分析器 配合使用GNU m4： m4 宏预处理器GNU Debugger（GDB）：代码调试工具GNU构建系统（autotools） —— GNU工具链 - 维基百科，自由的百科全书 QEMU QEMU 是一个很棒的模拟器，可以通过动态的二进制转换，模拟CPU，因此能够让我们在 x86 的电脑上模拟出 RISC-V 的运行环境，便于我们的开发测试，还可以和 GDB 联动调试，非常方便。我们的系统很小很简单，因此也完全不需要考虑性能之类的问题，只要能跑起来就可以了。 此外，QEMU 还内置了 OpenSBI，在我们编译好的可以模拟 64 位 RISC-V 的 QEMU 5.1 中内置的是 OpenSBI v0.7，指令集支持到了 RV64ACDFIMSU。 RV64ACDFIMSU： 原子指令(A) 压缩指令(C) 双精度浮点运算(D) 单精度浮点运算(F) 整数运算(RV64I) 整数乘除法(M) 特权级 M 模式（machine mode） S 模式（supervisor mode） U 模式（user mode） 参考资料 理解 SBI： riscv-sbi-doc: SBI 规范。后续我们会封装其中一部分 ecall 调用（环境调用）。 理解 RISC-V 指令集和汇编语言： RISC-V Assembly Language：RISC-V 官方的汇编语言教程。篇幅很短，都是例子，需要有 RISC-V 指令的基础。 RISC-V Reader（中译版）：完整的 RISC-V 教程，包括主要的指令集拓展和汇编语言。该书假设读者有计算机组成原理、体系结构的知识，了解至少一种指令集，有使用汇编语言编程的经验。 《计算机组成与设计-硬件/软件接口（原书第 5 版）》：RISC-V 的两位主要设计者撰写的教材。第二章介绍 RISC-V 指令，并使用 RISC-V 指令编程。该书假设读者没有任何关于计算机组成原理和汇编语言的知识。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2021-01-22 03:00:21 "},"ready/env.html":{"url":"ready/env.html","title":"环境部署","keywords":"","body":"环境部署 这里我们主要安装几个上篇介绍过的开发环境，这里主要介绍 Ubuntu 环境下的配置安装过程，在 Ubuntu 18.04.5 LTS 以及 Linux Mint 20.1 上测试通过，其余发行版请根据自身情况安装相应软件包。 首先我们先来安装几个必要的软件包，其中一部分是用于编译 QEMU 和 GDB 的，这里也顺带安装了 git、tmux、gcc-riscv64-linux-gnu 等工具，其中gcc-riscv64-linux-gnu就是我们所用的交叉编译器。 sudo apt install -y git build-essential pkg-config libglib2.0-dev libpixman-1-dev binutils libgtk-3-dev texinfo make libncurses5-dev tmux gcc-riscv64-linux-gnu Ubuntu 的软件源中没有支持模拟RISC-V的QEMU和支持调试RISC-V的GDB，需要我们自行编译源码安装。下载 QEMU 5.1.0 和 GDB 10.1 的源码包，可以选择官网下载，也可以下载前面给出的我们放在 gitee 上的源码包（国内下载稍快些）。选择这两个版本也没有什么原因，就是系统编写时的最新稳定版罢了，其中 QEMU 5.1.0 恰好也比 QEMU 5.0.0 多了OpenSBI中对 HART_STATE_EXTENTION 的支持。 下载完成后解压即可： tar xJf qemu-5.1.0.tar.xz #解压qemu包 tar xJf gdb-10.1.tar.xz #解压gdb包 进入解压后的 QEMU 源码目录，使用如下配置编译安装，这里配置了 QEMU 的模拟目标架构是32位和64位的 RISC-V，同时编译图形界面（使用 GTK 图形界面库，一个 Linux 下主流的图形界面库）。 ./configure --target-list=riscv32-softmmu,riscv64-softmmu --enable-gtk make -j$(nproc) #编译 sudo make install #安装 进入解压后的 GDB 源码目录，使用如下配置编译安装，配置了 GDB 的目标调试架构是 RISC-V 64位，同时编译 TUI 界面（文本用户界面）模式。 ./configure --target=riscv64-unknown-elf --enable-tui=yes make -j$(nproc) sudo make install #安装 这样安装就大致完成了，可以输入以下命令检测编译安装的软件的版本信息： riscv64-unknown-elf-gdb -v # 打印gdb版本信息 qemu-system-riscv64 --version # 打印qemu版本信息 应该能看到这样的信息： QEMU emulator version 5.1.0 Copyright (c) 2003-2020 Fabrice Bellard and the QEMU Project developers GNU gdb (GDB) 10.1 Copyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. 执行 qemu-system-riscv64 -machine virt -nographic，可以看到如下输出： OpenSBI v0.7 ____ _____ ____ _____ / __ \\ / ____| _ \\_ _| | | | |_ __ ___ _ __ | (___ | |_) || | | | | | '_ \\ / _ \\ '_ \\ \\___ \\| _ 表示QEMU可正常使用。 Qemu 可以使用 Ctrl + A 再按下 x 退出（注意要松开 Ctrl 和 A 再单独按x，这是一套组合按键，并不是只按 Ctrl + A 就可以的）。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2021-01-22 03:00:21 "},"helloworld/":{"url":"helloworld/","title":"你好，世界","keywords":"","body":"你好，世界 在这一章，我们会构建并启动到一个能输出一些检测信息和字符串的最简单的系统内核，同时也会介绍一些在这过程中需要用到的编译、链接和各种配置的知识和 RISC-V 的启动过程相关知识。 本章对应代码：lab1 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2021-01-22 03:00:21 "},"helloworld/main.html":{"url":"helloworld/main.html","title":"“主”函数的编写","keywords":"","body":"“主”函数的编写 关于“主”函数的一些说明 通常我们的 C 语言程序都会有一个主函数（main 函数）作为程序的入口，在这里我们也先写一个 main 函数作为我们的内核的“主”函数，之所以在“主”函数上加引号，是因为实际上这个函数并不是整个系统真正的入口，而 main 的名字也是可以任意取的，这一细节后续还会再提到，在这里还是遵循我们的习惯，将它取名为 main。 相关函数的介绍 在编写操作系统时是有很多地方与编写普通程序有很大的不同的，首先就是写代码的时候无法使用一些常用的头文件，如 stdio.h, stdlib.h 等，因为这些头文件是依赖于系统的实现的，换句话说，这些头文件的功能并不是 C 语言或编译器天生就具备的，而是由操作系统提供了底层支持，由操作系统完成了内部的一些函数和定义。 既然不能使用这些头文件，我们就无法使用 printf, scanf, puts, gets, putchar, getchar 之类的函数。好在，sbi 为我们提供了一些字符输入输出的环境调用功能，但是需要我们使用汇编语言来调用，因此我们会对这些功能做 C 语言的函数封装，这样我们就能借助我们自己封装的 C 语言函数使用它们了。 在 main 函数中，我们使用了这几个封装： sbi_probe_extension 探测 SBI 扩展的可用情况 sbi_console_putchar 打印字符 sbi_get_impl_id 获取当前的 SBI（Supervisor 二进制接口）实现 ID 同样我们也自己定义了一个符合 sbi 标准的结构体类型struct sbiret，用于表示一些 sbi 环境调用的返回值。在 main 函数中，主要是 sbi_probe_extension 函数使用了这个结构体，返回的值中若成员 value 的值不为0，则表示功能扩展可用，这些标准都会在后续介绍到，此处暂且不提。 另外我们又对 sbi_console_putchar 做了进一步封装，封装后函数名为 kputs，可以直接输出字符串，并在最后输出换行，封装代码如下： static void kputs(const char *msg) { for ( ; *msg != '\\0'; ++msg ) { sbi_console_putchar(*msg); } sbi_console_putchar('\\n'); } “主”函数代码与功能介绍 在这里给出 main 函数的代码： int main() { struct sbiret ret; ret = sbi_probe_extension(TIMER_EXTENTION); if (ret.value != 0) kputs(\"TIMER_EXTENTION: available\"); else kputs(\"TIMER_EXTENTION: unavailable\"); ret = sbi_probe_extension(SHUT_DOWN_EXTENTION); if (ret.value != 0) kputs(\"SHUT_DOWN_EXTENTION: available\"); else kputs(\"SHUT_DOWN_EXTENTION: unavailable\"); ret = sbi_probe_extension(HART_STATE_EXTENTION); if (ret.value != 0) kputs(\"HART_STATE_EXTENTION: available\"); else kputs(\"HART_STATE_EXTENTION: unavailable\"); ret = sbi_get_impl_id(); switch (ret.value) { case BERKELY_BOOT_LOADER: kputs(\"Implemention ID: Berkely boot loader\"); break; case OPENSBI: kputs(\"Implemention ID: OpenSBI\"); break; case XVISOR: kputs(\"Implemention ID: XVISOR\"); break; case KVM: kputs(\"Implemention ID: KVM\"); break; case RUSTSBI: kputs(\"Implemention ID: RustSBI\"); break; case DIOSIX: kputs(\"Implemention ID: DIOSIX\"); break; default: kputs(\"Implemention ID: Unkonwn\"); } kputs(\"Hello LZU OS\"); while (1) ; /* infinite loop */ return 0; } 根据前面的说明，我们很容易读通这个程序，它所做的不过就是检测TIMER_EXTENTION（时钟）、SHUT_DOWN_EXTENTION（关机）、HART_STATE_EXTENTION（硬件级线程，这一拓展我们实际并不会使用，只是单纯的检测一下）这几个 sbi 扩展是否可用 (available) ，检测当前 sbi 的实现，最后输出\"Hello LZU OS\"，随后陷入死循环。 小知识：HART 硬件级线程 hart 是硬件线程(hardware thread)的缩略形式。 我们用该术语将它们与大多数程序员熟悉的软件线程区分开来。软件线程在 harts 上进行分时复用。 大多数处理器核都只有一个hart。—— 摘自《RISC-V 手册》 如果一个部件包含了一个独立的取指令单元，则该部件被称为核心(core)。一个RiscV兼容的核心能够通过多线程技术(或者说超线程技术)支持多个RiscV兼容硬件线程(harts)，harts这儿就是指硬件线程， hardware thread的意思。所谓超线程技术，就是在一个硬件核中，实现多份硬件线程，每个硬件线程都有自己独立的寄存器组等上下文资源，但大多数的运算资源都被所有线程复用，因此面积效率很高。超线程最早出现是在Intel的处理器中。—— 摘自 Risc-V简要概括 ( archive.is互联网存档 ) 简而言之，硬件级线程和现在常见的 x86 处理器上的“m 核 n 线程”中的“n 线程”对应，若处理器设计时没有做超线程，那么一个核心就是一个硬件及线程，若有做超线程，那么某些核心可以有多个线程。 为什么 main 函数到最后是陷入死循环而不是退出呢？我们在讲完完整的启动流程后再来回顾这个问题。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2021-01-22 03:00:21 "},"helloworld/packaging.html":{"url":"helloworld/packaging.html","title":"ecall 指令的封装","keywords":"","body":"封装 ecall 指令 [ ] 解释 ecall [ ] 为什么要封装 [ ] 解释内联汇编 [ ] 解释如何封装 [ ] sbi-doc 标准 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2021-01-22 03:00:21 "},"helloworld/boot.html":{"url":"helloworld/boot.html","title":"操作系统的启动","keywords":"","body":"操作系统的启动 [ ] 开机加载SBI（内存地址） [ ] SBI加载内核（内存地址） [ ] 内核如何加载 [ ] entry.s的解释 [ ] 如何进入main函数的 [ ] 为什么说main函数并不是整个系统真正的入口，系统真正的入口在哪里（entry.s，0x80200000） 为什么 main 函数到最后是陷入死循环而不是退出呢？ 可以分两种情况来思考一下这个问题： 如果这是一个最顶层的 C 语言函数（当前代码就是这种情况，这个函数不是被其他的 C 语言函数调用的），结束时没有陷入死循环，那么函数结束自然就会返回（函数体的右大括号就代表了函数返回，无论是否有 return 语句） 在常规操作系统中，一个进程最顶层的函数结束了，会返回到创建这个进程的父进程，如果是在命令行中执行的进程，那么这个父进程就是 shell 程序。 在我们的操作系统中，是汇编程序 entry.s 调用了 main 函数，反汇编 entry.s 编译出来的目标文件 entry.o 可以看出它将调用 main 函数的那行指令的内存地址压入栈中，便于结束调用时返回，那么被调用的函数结束时返回到的指令执行位置就是调用它的那行语句，那么它就会被再次调用，也就是会出现不断循环 main 函数的情况（可以在 main 函数里删去最后的循环就能看到这个现象）。 如果是汇编语言结束，没有陷入死循环 汇编语言其实没有结束的概念，CPU 只会不断地取指、执行，若没有跳转语句，CPU 会不断往下执行，即使内存后面存储的已经不是我们所希望计算机执行的指令了。在这之后可能是无意义的内存内容，或者是我们在内存中存的数据，或者是我们原本存在后面的等待被调用的函数，但 CPU 不会理解它们到底是什么，它只会不断地向后取值，并把它们当作正常指令来执行，因此就会出现各种预期之外的执行结果。 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2021-01-22 03:00:21 "},"helloworld/make.html":{"url":"helloworld/make.html","title":"拼搭我们的系统","keywords":"","body":"拼搭我们的系统 [ ] 编写完成后我们需要将我们的系统编译并拼接起来（介绍词） 编译链接我们的代码 [ ] 我们的系统是如何被编译链接的（参考makefile的注释） [ ] 可以加一点make的知识 [ ] 参考资料：https://www.ruanyifeng.com/blog/2015/02/make.html [ ] 参考资料：https://seisman.github.io/how-to-write-makefile/implicit_rules.html [ ] 链接脚本(linker.ld)是什么意思 执行与调试的启动 [ ] 如何启动系统，在makefile里是怎么体现的 [ ] 如何进入调试，在makefile里是怎么体现的 By Hanabi，使用署名-非商业性使用-相同方式共享 4.0 国际发布            此页面修订于： 2021-01-22 03:00:21 "}}