# 操作系统的启动

- [ ] 开机加载SBI（内存地址）
- [ ] SBI加载内核（内存地址）
- [ ] 内核如何加载
  - [ ] entry.s的解释
  - [ ] 如何进入main函数的
  - [ ] 为什么说main函数并不是整个系统真正的入口，系统真正的入口在哪里（entry.s，0x80200000）

为什么 main 函数到最后是陷入死循环而不是退出呢？

可以分两种情况来思考一下这个问题：

1. 如果这是一个最顶层的 C 语言函数（当前代码就是这种情况，这个函数不是被其他的 C 语言函数调用的），结束时没有陷入死循环，那么函数结束自然就会返回（函数体的右大括号就代表了函数返回，无论是否有 `return` 语句）
   - 在常规操作系统中，一个进程最顶层的函数结束了，会返回到创建这个进程的父进程，如果是在命令行中执行的进程，那么这个父进程就是 shell 程序。
   - 在我们的操作系统中，是汇编程序 `entry.s` 调用了 `main` 函数，反汇编 `entry.s` 编译出来的目标文件 `entry.o` 可以看出它将调用 `main` 函数的那行指令的内存地址压入栈中，便于结束调用时返回，那么被调用的函数结束时返回到的指令执行位置就是调用它的那行语句，那么它就会被再次调用，也就是会出现不断循环 `main` 函数的情况（可以在 `main` 函数里删去最后的循环就能看到这个现象）。
2. 如果是汇编语言结束，没有陷入死循环
   - 汇编语言其实没有结束的概念，CPU 只会不断地取指、执行，若没有跳转语句，CPU 会不断往下执行，即使内存后面存储的已经不是我们所希望计算机执行的指令了。在这之后可能是无意义的内存内容，或者是我们在内存中存的数据，或者是我们原本存在后面的等待被调用的函数，但 CPU 不会理解它们到底是什么，它只会不断地向后取值，并把它们当作正常指令来执行，因此就会出现各种预期之外的执行结果。
